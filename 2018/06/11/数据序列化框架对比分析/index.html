<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>数据序列化框架对比分析 | 杜政颉的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="概览 由于独立于应用系统，分布式缓存的本质就是将所有的业务数据对象序列化为字节数组，然后保存到自己的内存中。所使用的序列化方案也自然会成为影响系统性能的关键点之一。一般来说，我们对一个序列化框架的关注主要有以下几点：      序列化速度：即对一个普通对象，将其从内存对象转换为字节数组需要多长时间；这个当然是越快越好   对象压缩比：即序列化后生成对象的与原内存对象的体积比   支持的数据类型范围">
<meta name="keywords" content="技术">
<meta property="og:type" content="article">
<meta property="og:title" content="数据序列化框架对比分析">
<meta property="og:url" content="https://git-duzhengjie.github.io/2018/06/11/数据序列化框架对比分析/index.html">
<meta property="og:site_name" content="杜政颉的博客">
<meta property="og:description" content="概览 由于独立于应用系统，分布式缓存的本质就是将所有的业务数据对象序列化为字节数组，然后保存到自己的内存中。所使用的序列化方案也自然会成为影响系统性能的关键点之一。一般来说，我们对一个序列化框架的关注主要有以下几点：      序列化速度：即对一个普通对象，将其从内存对象转换为字节数组需要多长时间；这个当然是越快越好   对象压缩比：即序列化后生成对象的与原内存对象的体积比   支持的数据类型范围">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2018-06-11T07:35:27.021Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="数据序列化框架对比分析">
<meta name="twitter:description" content="概览 由于独立于应用系统，分布式缓存的本质就是将所有的业务数据对象序列化为字节数组，然后保存到自己的内存中。所使用的序列化方案也自然会成为影响系统性能的关键点之一。一般来说，我们对一个序列化框架的关注主要有以下几点：      序列化速度：即对一个普通对象，将其从内存对象转换为字节数组需要多长时间；这个当然是越快越好   对象压缩比：即序列化后生成对象的与原内存对象的体积比   支持的数据类型范围">
  
    <link rel="alternate" href="/atom.xml" title="杜政颉的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">杜政颉的博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">天行健，君子以自强不息；地势坤，君子以厚德载物</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://git-duzhengjie.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-数据序列化框架对比分析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/11/数据序列化框架对比分析/" class="article-date">
  <time datetime="2018-06-11T07:31:19.436Z" itemprop="datePublished">2018-06-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      数据序列化框架对比分析
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><blockquote>
<p>由于独立于应用系统，分布式缓存的本质就是将所有的业务数据对象序列化为字节数组，然后保存到自己的内存中。所使用的序列化方案也自然会成为影响系统性能的关键点之一。一般来说，我们对一个序列化框架的关注主要有以下几点：  </p>
</blockquote>
<blockquote>
<ol>
<li>序列化速度：即对一个普通对象，将其从内存对象转换为字节数组需要多长时间；这个当然是越快越好  </li>
<li>对象压缩比：即序列化后生成对象的与原内存对象的体积比  </li>
<li>支持的数据类型范围：序列化框架都支持什么样的数据结构；对于大部分的序列化框架来说，都会支持普通的对象类型，但是对于复杂对象（比如说多继承关系、交叉引用、集合类等）可能不支持或支持的不够好  </li>
<li>易用性：一个好的序列化框架必须也是使用方便的，不需要用户做太多的依赖或者额外配置  </li>
</ol>
</blockquote>
<p>对于一个序列化框架来说，以上几个特性很难都做到很出色，这是一个鱼和熊掌不可兼得的东西（具体原因后面会介绍），但是终归有自己的优势和特长，需要使用者根据实际场景仔细考量。下面就针对目前主流的序列化框架：Java、Hessian、ProtoBuf、Kryo分别从速度、压缩比、支持对象类型和易用性几方面分别讨论。  </p>
<h1 id="压缩比对比"><a href="#压缩比对比" class="headerlink" title="压缩比对比"></a>压缩比对比</h1><p>单位：字节<br>||<strong>工具</strong>||Java||Hessian||ProtoBuf||Kryo||<br>||<strong>仅数字</strong> ||392 || 252||59 ||56 ||<br>|| <strong>数字 + 字符串</strong>||494 ||351 || 161|| 149||  </p>
<h1 id="序列化速度对比"><a href="#序列化速度对比" class="headerlink" title="序列化速度对比"></a>序列化速度对比</h1><p>单位：纳秒<br>||<strong>工具</strong>||Java||Hessian||ProtoBuf||Kryo||<br>||<strong>仅数字</strong> ||8733|| 6140||1154||2010||<br>|| <strong>数字 + 字符串</strong>||12497||7863|| 2978|| 2863||  </p>
<h1 id="支持对象类型与易用性对比"><a href="#支持对象类型与易用性对比" class="headerlink" title="支持对象类型与易用性对比"></a>支持对象类型与易用性对比</h1><ul>
<li><p>Java源生序列化  </p>
<blockquote>
<p>ava源生序列化是JDK自带的对象序列化方式，也是我们最常用的一种；其优点是简单、方便，不需要额外的依赖而且大部分三方系统或框架都支持；目前看来，Java源生序列化的兼容性也是最好的，可支持任何实现了Serializable接口的对象（包括多继承、循环引用、集合类等等）。但随之而来不可避免的就是，其序列化的速度和生成的对象体积和其他序列化框架相比，几乎都是最差的  </p>
</blockquote>
</li>
<li><p>Hessian  </p>
<blockquote>
<p>Hessian的序列化实现和Java的原生序列化很相似，只是对于序列化反序列化本身并不需要的一些元数据进行了删减；所以Hessian可以像Java的源生序列化那样，可以支持任意类型的对象；但是在存储上，Hessian并没有做相应的优化，所以其生成的对象体积相较于Java的源生序列化并没有下降太多。由于Hessian相较于Java源生序列化并没有太大的优势，所以一般情况下，如果系统中没有使用Hessian的rpc框架，则很少单独使用Hessian的序列化机制。  </p>
</blockquote>
</li>
<li><p>Google Protobuf  </p>
<blockquote>
<p>GPB最大的特点就是自己定义了一套自己数据类型，并且规定只允许用我的这套；所以在使用GPB的时候，我们不得不为它单独定义一个描述文件，或者叫schema文件，用来完成Java对象中的基本数据类型和GPB自己定义的类型之间的一个映射。不过也正是GPB对类型的自定义，也让他可以更好的针对这些类型做出存储和解析上的优化，从而避免了Java源生序列化中的诸多弱点。对于对象属性，GPB并没有直接存储属性名称，而是根据schema文件中的映射关系，只保存该属性的顺序id；而对于，GPB针对常用的几种数据类型采用了不同程度的压缩，同时属性区段之间采用特定标记进行分隔，这样可以大大减少存储所占用的空间。对于数值类型，常见的压缩方式有变长byte、分组byte、差值存储等，一般都是根据属性的使用特点来做定制化的压缩策略。GPB的另一个优点就是跨语言，支持Java、C、PHP、Python等目前比较大众的语言；其他类似的还有Facebook的Thrift，也需要描述文件的支持，同时也包含了一个rpc框架和更丰富的语言支持  </p>
</blockquote>
</li>
<li><p>Kryo  </p>
<blockquote>
<p>前面我们提到，诸如Hessian和GPB这些三方的序列化框架或多或少的都对Java原生序列化机制做出了一些改进；而对于Kryo来说，改进无疑是更彻底一些；在很多评测中，Kryo的数据都是遥遥领先的；Kryo的处理和Google Protobuf类似。但有一点需要说明的是，Kryo在做序列化时，也没有记录属性的名称，而是给每个属性分配了一个id，但是他却并没有GPB那样通过一个schema文件去做id和属性的一个映射描述，所以一旦我们修改了对象的属性信息，比如说新增了一个字段，那么Kryo进行反序列化时就可能发生属性值错乱甚至是反序列化失败的情况；而且由于Kryo没有序列化属性名称的描述信息，所以序列化/反序列化之前，需要先将要处理的类在Kryo中进行注册，这一操作在首次序列化时也会消耗一定的性能。另外需要提一下的就是目前kryo目前还只支持Java语言。  </p>
</blockquote>
</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.cnblogs.com/siqi/p/5096317.html" target="_blank" rel="noopener">https://www.cnblogs.com/siqi/p/5096317.html</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://git-duzhengjie.github.io/2018/06/11/数据序列化框架对比分析/" data-id="cji9xvr7v0004oku27qmfw931" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/06/11/高性能分布式数据缓存系统研究/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          高性能分布式数据缓存系统研究
        
      </div>
    </a>
  
  
    <a href="/2018/06/11/kubernetes自动扩容功能剖析/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">kubernetes自动扩容功能剖析</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/06/11/高性能分布式数据缓存系统研究/">高性能分布式数据缓存系统研究</a>
          </li>
        
          <li>
            <a href="/2018/06/11/数据序列化框架对比分析/">数据序列化框架对比分析</a>
          </li>
        
          <li>
            <a href="/2018/06/11/kubernetes自动扩容功能剖析/">kubernetes自动扩容功能剖析</a>
          </li>
        
          <li>
            <a href="/2018/06/11/Kafka高性能吞吐揭秘/">Kafka高性能吞吐揭秘</a>
          </li>
        
          <li>
            <a href="/2018/06/11/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 杜政颉<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>